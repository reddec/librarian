package main

import (
	"flag"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/fatih/camelcase"
	"github.com/fatih/structtag"
	"github.com/reddec/godetector"
	"github.com/reddec/godetector/deepparser"
)

func main() {
	out := flag.String("out", "", "output file, empty for stdout")
	flag.Parse()

	var gen *jen.File
	if *out == "" || *out == "-" {
		gen = jen.NewFile("generated")
	} else {
		info, err := godetector.InspectDirectory(filepath.Dir(*out))
		if err != nil {
			panic(err)
		}
		imp := info.ToImport()
		gen = jen.NewFilePathName(imp.Path, imp.Package)
	}
	gen.PackageComment("Code generated by librarian. DO NOT EDIT.")

	for _, fileName := range flag.Args() {

		var fs token.FileSet
		file, err := parser.ParseFile(&fs, fileName, nil, parser.AllErrors)
		if err != nil {
			panic(err)
		}

		ast.Inspect(file, func(node ast.Node) bool {
			if typeDef, ok := node.(*ast.TypeSpec); ok {
				if structDef, ok := typeDef.Type.(*ast.StructType); ok {
					indexes := inspectStruct(typeDef, structDef, &fs)
					if len(indexes) > 0 {
						gen.Add(generateTypes(typeDef, file, &fs, indexes, filepath.Dir(fileName)))
					}
				}
			}
			return true
		})
	}

	var stream io.Writer
	if *out == "" || *out == "-" {
		stream = os.Stdout
	} else {
		f, err := os.Create(*out)
		if err != nil {
			panic(err)
		}
		defer f.Close()
		stream = f
	}

	err := gen.Render(stream)
	if err != nil {
		panic(err)
	}
}

func generateTypes(typeDef *ast.TypeSpec, file *ast.File, tokenSet *token.FileSet, indexes []fieldIndex, dir string) jen.Code {
	typeName := typeDef.Name.String()
	definition := deepparser.FindDefinitionFromAst(typeName, "", file, dir)

	if definition == nil {
		panic("definition not found")
	}
	storageName := typeName + "Storage"
	metaName := "meta" + storageName
	itemType := jen.Qual(definition.Import.Path, typeName)
	encoderType := jen.Func().Params(jen.Id("item").Add(itemType)).Params(jen.Index().Byte(), jen.Error())
	decoderType := jen.Func().Params(jen.Id("data").Index().Byte(), jen.Id("item").Op("*").Add(itemType)).Error()
	constructorName := "New" + storageName
	// constructor - full
	main := jen.Comment(constructorName+" creates indexed storage for "+typeName+".").Line().Func().Id("New"+storageName).Params(
		jen.Id("backend").Qual("github.com/reddec/librarian", "Storage"),
		jen.Id("encoder").Add(encoderType),
		jen.Id("decoder").Add(decoderType),
	).Op("*").Id(storageName).BlockFunc(func(group *jen.Group) {
		group.Return().Op("&").Id(storageName).ValuesFunc(func(values *jen.Group) {
			values.Id("backend").Op(":").Id("backend")
			values.Id("encoder").Op(":").Id("encoder")
			values.Id("decoder").Op(":").Id("decoder")
		})
	}).Line().Line()
	// constructor - JSON
	fnName := "New" + storageName + "JSON"
	main.Comment(fnName + " create new indexed storage for " + typeName + " with custom storage backend, with data encoded in JSON.").Line().
		Func().Id(fnName).Params(
		jen.Id("backend").Qual("github.com/reddec/librarian", "Storage"),
	).Op("*").Id(storageName).BlockFunc(func(group *jen.Group) {
		group.Return().Id(constructorName).Call(
			jen.Id("backend"),
			encoderType.Clone().BlockFunc(func(encoder *jen.Group) {
				encoder.Return().Qual("encoding/json", "Marshal").Call(jen.Id("item"))
			}),
			decoderType.Clone().BlockFunc(func(decoder *jen.Group) {
				decoder.Return().Qual("encoding/json", "Unmarshal").Call(jen.Id("data"), jen.Id("item"))
			}),
		)
	}).Line().Line()
	// constructor - file JSON
	fnName = "New" + storageName + "FilesJSON"
	main.Comment(fnName + " creates new indexed storage for " + typeName + " with files in directory as backend storage, with data encoded in JSON.").Line().
		Func().Id(fnName).Params(
		jen.Id("directory").String(),
	).Op("*").Id(storageName).BlockFunc(func(group *jen.Group) {
		group.Return().Id(constructorName).Call(
			jen.Qual("github.com/reddec/librarian", "Directory").Call(jen.Id("directory")),
			encoderType.Clone().BlockFunc(func(encoder *jen.Group) {
				encoder.Return().Qual("encoding/json", "Marshal").Call(jen.Id("item"))
			}),
			decoderType.Clone().BlockFunc(func(decoder *jen.Group) {
				decoder.Return().Qual("encoding/json", "Unmarshal").Call(jen.Id("data"), jen.Id("item"))
			}),
		)
	}).Line().Line()
	// storage struct
	main.Comment("Indexed storage for " + asWord(typeName) + ".").
		Line().Type().Id(storageName).StructFunc(func(group *jen.Group) {
		group.Id("backend").Qual("github.com/reddec/librarian", "Storage")
		group.Id("encoder").Add(encoderType)
		group.Id("decoder").Add(decoderType)
		group.Id("lock").Qual("sync", "RWMutex")
		group.Id("meta").Map(jen.String()).Id(metaName).Comment("minimal meta information for indexes")
		for _, index := range indexes {
			if index.Unique {
				group.Id(index.indexFieldName()).Map(jen.Id(deepparser.AstPrint(index.Field.Type, tokenSet))).String()
			} else {
				group.Id(index.indexFieldName()).Map(jen.Id(deepparser.AstPrint(index.Field.Type, tokenSet))).Map(jen.String()).Bool()
			}
		}
	})

	main.Line().Line()

	// synchronize index and real storage
	main.Add(synchronize(storageName, typeName, constructorName, itemType, indexes)).Line()
	// get all items
	main.Add(getAll(storageName, typeName, itemType)).Line()
	// access by indexed field
	for _, index := range indexes {
		if index.Unique {
			main.Add(getSingle(storageName, typeName, itemType, index)).Line()
		} else {
			main.Add(getMulti(storageName, typeName, itemType, index)).Line()
		}
	}
	// remove item
	for _, index := range indexes {
		if index.Unique {
			main.Add(removeSingle(storageName, typeName, index)).Line()
		} else {
			main.Add(removeMulti(storageName, typeName, index)).Line()
		}
	}
	// updates - possible only for unique indexes
	for _, index := range indexes {
		if !index.Unique {
			continue
		}
		main.Add(updateSingle(storageName, typeName, itemType, index)).Line()
	}
	// upsert
	for _, index := range indexes {
		if !index.Unique {
			continue
		}
		main.Add(upsertSingle(storageName, typeName, itemType, index)).Line()
	}
	// add item
	instanceName := asVarName(typeName)
	main.Add(add(storageName, instanceName, typeName, itemType)).Line()
	// update item
	main.Add(update(storageName, instanceName, typeName, itemType)).Line()
	// supporting functions
	// - indexer
	main.Add(indexItem(storageName, metaName, itemType, indexes)).Line()
	// - index remover
	main.Add(removeFromIndex(storageName, indexes)).Line()
	// - remover
	main.Add(remover(typeName, storageName)).Line()
	// - getter
	main.Add(getter(typeName, itemType, storageName)).Line()
	// - unique constraints
	main.Add(uniqueConstraints(typeName, itemType, storageName, indexes)).Line()
	// - internal add
	main.Add(addInternal(storageName, instanceName, typeName, itemType))
	// meta data
	main.Type().Id(metaName).StructFunc(func(meta *jen.Group) {
		for _, index := range indexes {
			meta.Id(index.Name()).Id(deepparser.AstPrint(index.Field.Type, tokenSet))
		}
	})
	main.Line().Line()
	return main
}

func synchronize(storageName, typeName, constructorName string, itemType jen.Code, indexes []fieldIndex) jen.Code {
	return jen.Comment("Synchronize backend storage and index.\n" +
		"Will iterate over all items one-by-one and add to internal index indexed fields (not object itself).\n" +
		"Will block storage only at the moment when all items processed.\n" +
		"In case of error - internal index will not be changed.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("Synchronize").
		Params(jen.Id("ctx").Qual("context", "Context")).Error().BlockFunc(func(sync *jen.Group) {
		sync.Id("live").Op(":=").Id(constructorName).Call(
			jen.Id("storage").Dot("backend"),
			jen.Id("storage").Dot("encoder"),
			jen.Id("storage").Dot("decoder"))
		sync.Err().Op(":=").Id("storage").Dot("backend").Dot("Iterate").Call(jen.Id("ctx"),
			jen.Func().Params(jen.Id("id").String(), jen.Id("data").Index().Byte()).Error().BlockFunc(func(iterator *jen.Group) {
				iterator.Var().Id("item").Add(itemType)
				iterator.Err().Op(":=").Id("storage").Dot("decoder").Call(jen.Id("data"), jen.Op("&").Id("item"))
				iterator.If().Err().Op("!=").Nil().Block(
					jen.Return().Qual("fmt", "Errorf").Call(jen.Lit("decode "+typeName+"#%s data: %w"), jen.Id("id"), jen.Err()),
				)
				iterator.Id("live").Dot("indexItem").Call(jen.Id("item"), jen.Id("id"))
				iterator.Return().Nil()
			}))
		sync.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("synchronize "+asWord(typeName)+": %w"), jen.Err()))
		})
		sync.Id("storage").Dot("lock").Dot("Lock").Call()
		sync.Defer().Id("storage").Dot("lock").Dot("Unlock").Call().Line()
		sync.Id("storage").Dot("meta").Op("=").Id("live").Dot("meta")
		for _, index := range indexes {
			sync.Id("storage").Dot(index.indexFieldName()).Op("=").Id("live").Dot(index.indexFieldName())
		}
		sync.Return().Nil()
	}).Line()
}

func getAll(storageName, typeName string, itemType *jen.Statement) jen.Code {
	return jen.Comment("All known objects without filtration.\n"+
		"Returning slice is not sorted and order is not stable.\n"+
		"Use with caution! All objects will be stored in memory and may cause high GC usage as well as high memory consumption.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("All").
		Params(jen.Id("ctx").Qual("context", "Context")).
		Params(jen.Index().Add(itemType), jen.Error()).BlockFunc(func(all *jen.Group) {
		all.Id("storage").Dot("lock").Dot("RLock").Call()
		all.Defer().Id("storage").Dot("lock").Dot("RUnlock").Call().Line()
		all.Var().Id("ans").Op("=").Make(jen.Index().Add(itemType), jen.Lit(0), jen.Len(jen.Id("storage").Dot("meta")))
		all.For().Id("id").Op(":=").Range().Id("storage").Dot("meta").BlockFunc(func(iter *jen.Group) {
			iter.List(jen.Id("item"), jen.Err()).Op(":=").Id("storage").Dot("get").Call(jen.Id("ctx"), jen.Id("id"))
			iter.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
				failed.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("list all "+asWord(typeName)+": %w"), jen.Err()))
			})
			iter.Id("ans").Op("=").Append(jen.Id("ans"), jen.Id("item"))
		})
		all.Return(jen.Id("ans"), jen.Nil())
	}).Line()
}

func getSingle(storageName, typeName string, itemType *jen.Statement, index fieldIndex) jen.Code {
	paramName := asVarName(index.Field.Names[0].Name)
	paramType := index.fieldType()
	return jen.Comment(index.accessor()+" returns single "+typeName+" object filtered by "+asWord(paramName)+".\n"+
		"If nothing found - error will be returned together with empty object.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id(index.accessor()).
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id(paramName).Add(paramType)).
		Params(jen.Add(itemType), jen.Error()).BlockFunc(func(byIndex *jen.Group) {
		byIndex.Id("storage").Dot("lock").Dot("RLock").Call()
		byIndex.Defer().Id("storage").Dot("lock").Dot("RUnlock").Call().Line()
		byIndex.List(jen.Id("id"), jen.Id("found")).Op(":=").
			Id("storage").Dot(index.indexFieldName()).Index(jen.Id(paramName))
		byIndex.If().Op("!").Id("found").Block(jen.Return(itemType.Clone().Values(), jen.Qual("fmt", "Errorf").Call(jen.Lit(asWord(typeName)+" not found by "+paramName+" %v"), jen.Id(paramName))))
		byIndex.List(jen.Id("item"), jen.Err()).Op(":=").Id("storage").Dot("get").Call(jen.Id("ctx"), jen.Id("id"))
		byIndex.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return(itemType.Clone().Values(), jen.Qual("fmt", "Errorf").Call(jen.Lit("get "+asWord(typeName)+" by "+paramName+" %v: %w"), jen.Id(paramName), jen.Err()))
		})
		byIndex.Return(jen.Id("item"), jen.Nil())
	}).Line()
}

func getMulti(storageName, typeName string, itemType jen.Code, index fieldIndex) jen.Code {
	paramName := asVarName(index.Field.Names[0].Name)
	paramType := index.fieldType()
	return jen.Comment(index.accessor()+" returns multiple "+typeName+" objects filtered by "+asWord(paramName)+".\n"+
		"Returning slice is not sorted and order is not stable.\n"+
		"If nothing found - nil slice will be returned.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id(index.accessor()).
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id(paramName).Add(paramType)).
		Params(jen.Index().Add(itemType), jen.Error()).BlockFunc(func(byIndex *jen.Group) {
		byIndex.Id("storage").Dot("lock").Dot("RLock").Call()
		byIndex.Defer().Id("storage").Dot("lock").Dot("RUnlock").Call().Line()
		byIndex.Var().Id("result").Index().Add(itemType)
		byIndex.For().Id("id").Op(":=").Range().Id("storage").Dot(index.indexFieldName()).Index(jen.Id(paramName)).BlockFunc(func(loop *jen.Group) {
			loop.List(jen.Id("item"), jen.Err()).Op(":=").Id("storage").Dot("get").Call(jen.Id("ctx"), jen.Id("id"))
			loop.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
				failed.Return(jen.Id("result"), jen.Qual("fmt", "Errorf").Call(jen.Lit("list "+asWord(typeName)+" by "+asWord(paramName)+" %s: %w"), jen.Id(paramName), jen.Err()))
			})
			loop.Id("result").Op("=").Append(jen.Id("result"), jen.Id("item"))
		})

		byIndex.Return(jen.Id("result"), jen.Nil())
	}).Line()
}

func removeSingle(storageName, typeName string, index fieldIndex) jen.Code {
	fnName := "Remove" + index.accessor()
	paramName := asVarName(index.Field.Names[0].Name)
	paramType := index.fieldType()
	return jen.Comment(fnName+" removes single "+typeName+" object by "+asWord(paramName)+".\n"+
		"If nothing found - operation will be ignored without error.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id(fnName).
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id(paramName).Add(paramType)).Error().BlockFunc(func(byIndex *jen.Group) {
		byIndex.Id("storage").Dot("lock").Dot("Lock").Call()
		byIndex.Defer().Id("storage").Dot("lock").Dot("Unlock").Call().Line()
		byIndex.List(jen.Id("id"), jen.Id("found")).Op(":=").
			Id("storage").Dot(index.indexFieldName()).Index(jen.Id(paramName))
		byIndex.If().Op("!").Id("found").Block(jen.Return().Nil())
		byIndex.Err().Op(":=").Id("storage").Dot("remove").Call(jen.Id("ctx"), jen.Id("id"))
		byIndex.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("remove "+asWord(typeName)+" by "+paramName+" %v: %w"), jen.Id(paramName), jen.Err())
		})
		byIndex.Return().Nil()
	}).Line().Line()
}

func removeMulti(storageName, typeName string, index fieldIndex) jen.Code {
	fnName := "Remove" + index.accessor()
	paramName := asVarName(index.Field.Names[0].Name)
	paramType := index.fieldType()
	return jen.Comment(fnName+" removes multiple "+typeName+" objects filtered by "+asWord(paramName)+".\n"+
		"If nothing found - operation will be ignored without error.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id(fnName).
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id(paramName).Add(paramType)).Error().BlockFunc(func(byIndex *jen.Group) {
		byIndex.Id("storage").Dot("lock").Dot("Lock").Call()
		byIndex.Defer().Id("storage").Dot("lock").Dot("Unlock").Call().Line()

		byIndex.Var().Id("ids").Index().String()
		byIndex.For().Id("id").Op(":=").Range().Id("storage").Dot(index.indexFieldName()).Index(jen.Id(paramName)).BlockFunc(func(iter *jen.Group) {
			iter.Id("ids").Op("=").Append(jen.Id("ids"), jen.Id("id"))
		})
		byIndex.For().List(jen.Id("_"), jen.Id("id")).Op(":=").Range().Id("ids").BlockFunc(func(iter *jen.Group) {
			iter.Err().Op(":=").Id("storage").Dot("remove").Call(jen.Id("ctx"), jen.Id("id"))
			iter.If().Err().Op("!=").Nil().Block(jen.Return(
				jen.Qual("fmt", "Errorf").Call(jen.Lit("remove "+asWord(typeName)+" by "+paramName+" %v: %w"), jen.Id(paramName), jen.Err()),
			))
		})
		byIndex.Return().Nil()
	}).Line()
}

func upsertSingle(storageName, typeName string, itemType jen.Code, index fieldIndex) jen.Code {
	fnName := "Upsert" + index.accessor()
	paramName := asVarName(typeName)
	filterName := asVarName(index.Field.Names[0].Name)
	return jen.Comment(fnName+" updates or creates single "+typeName+" object by "+filterName+".\n"+
		"If object not exists - new object will be created.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id(fnName).
		Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id(paramName).Add(itemType),
		).Error().BlockFunc(func(updater *jen.Group) {
		updater.Id("storage").Dot("lock").Dot("Lock").Call()
		updater.Defer().Id("storage").Dot("lock").Dot("Unlock").Call().Line()
		updater.List(jen.Id("id"), jen.Id("exists")).Op(":=").Id("storage").Dot(index.indexFieldName()).Index(jen.Id(paramName).Dot(index.Name()))
		updater.If().Op("!").Id("exists").BlockFunc(func(failed *jen.Group) {
			failed.Return().Id("storage").Dot("add").Call(jen.Id("ctx"), jen.Id(paramName))
		})
		updater.Err().Op(":=").Id("storage").Dot("update").Call(jen.Id("ctx"), jen.Id("id"), jen.Id(paramName))
		updater.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("update "+asWord(typeName)+" with "+filterName+" %v: %w"), jen.Id(paramName).Dot(index.Name()), jen.Err())
		})
		updater.Return().Nil()
	}).Line()
}

func updateSingle(storageName, typeName string, itemType jen.Code, index fieldIndex) jen.Code {
	fnName := "Update" + index.accessor()
	paramName := asVarName(typeName)
	filterName := asVarName(index.Field.Names[0].Name)
	return jen.Comment(fnName+" updates single "+typeName+" object by "+filterName+".\n"+
		"If object not exists - error will be returned.").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id(fnName).
		Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id(paramName).Add(itemType),
		).Error().BlockFunc(func(updater *jen.Group) {
		updater.Id("storage").Dot("lock").Dot("Lock").Call()
		updater.Defer().Id("storage").Dot("lock").Dot("Unlock").Call().Line()
		updater.List(jen.Id("id"), jen.Id("exists")).Op(":=").Id("storage").Dot(index.indexFieldName()).Index(jen.Id(paramName).Dot(index.Name()))
		updater.If().Op("!").Id("exists").BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit(asWord(typeName)+" with "+filterName+" %v doesn't exist"), jen.Id(paramName).Dot(index.Name()))
		})
		updater.Err().Op(":=").Id("storage").Dot("update").Call(jen.Id("ctx"), jen.Id("id"), jen.Id(paramName))
		updater.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("update "+asWord(typeName)+" with "+filterName+" %v: %w"), jen.Id(paramName).Dot(index.Name()), jen.Err())
		})
		updater.Return().Nil()
	}).Line()
}

func add(storageName string, instanceName string, typeName string, itemType jen.Code) jen.Code {
	return jen.Comment("Add new "+instanceName+" to the storage and index.\n"+
		"If some of unique fields already exists - error will be returned (unique constraint violation).").Line().
		Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("Add").
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id(instanceName).Add(itemType)).Error().BlockFunc(func(setter *jen.Group) {
		setter.Id("storage").Dot("lock").Dot("Lock").Call()
		setter.Defer().Id("storage").Dot("lock").Dot("Unlock").Call().Line()
		setter.Err().Op(":=").Id("storage").Dot("unique").Call(jen.Id(instanceName))
		setter.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit(asWord(typeName)+" unique constraint violation: %w"), jen.Err())
		})

		setter.Return().Id("storage").Dot("add").Call(jen.Id("ctx"), jen.Id(instanceName))
	}).Line()
}

func addInternal(storageName string, instanceName string, typeName string, itemType jen.Code) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("add").
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id(instanceName).Add(itemType)).Error().BlockFunc(func(setter *jen.Group) {
		setter.List(jen.Id("data"), jen.Err()).Op(":=").Id("storage").Dot("encoder").Call(jen.Id(instanceName))
		setter.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("encode "+asWord(typeName)+": %w"), jen.Err())
		})
		setter.List(jen.Id("id"), jen.Err()).Op(":=").Id("storage").Dot("backend").Dot("Create").Call(jen.Id("ctx"), jen.Id("data"))
		setter.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("create "+asWord(typeName)+": %w"), jen.Err())
		})
		setter.Id("storage").Dot("indexItem").Call(jen.Id(instanceName), jen.Id("id"))

		setter.Return().Nil()
	}).Line()
}

func update(storageName string, instanceName string, typeName string, itemType jen.Code) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("update").
		Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("id").String(),
			jen.Id(instanceName).Add(itemType),
		).Error().BlockFunc(func(updater *jen.Group) {
		updater.List(jen.Id("data"), jen.Err()).Op(":=").Id("storage").Dot("encoder").Call(jen.Id(instanceName))
		updater.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("encode "+asWord(typeName)+" %s: %w"), jen.Id("id"), jen.Err())
		})
		updater.Err().Op("=").Id("storage").Dot("backend").Dot("Update").Call(jen.Id("ctx"), jen.Id("id"), jen.Id("data"))
		updater.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("update "+asWord(typeName)+" %s: %w"), jen.Id("id"), jen.Err())
		})
		updater.Id("storage").Dot("removeItemFromIndex").Call(jen.Id("id"))
		updater.Id("storage").Dot("indexItem").Call(jen.Id(instanceName), jen.Id("id"))

		updater.Return().Nil()
	}).Line()
}

func indexItem(storageName, metaName string, itemType jen.Code, indexes []fieldIndex) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("indexItem").Params(
		jen.Id("value").Add(itemType),
		jen.Id("id").String(),
	).BlockFunc(func(indexer *jen.Group) {
		for _, index := range indexes {
			if index.Unique {
				indexer.Id("storage").Dot(index.indexFieldName()).Index(jen.Id("value").Dot(index.Field.Names[0].String())).Op("=").Id("id")
			} else {
				indexStore := jen.Id("storage").Dot(index.indexFieldName()).Index(jen.Id("value").Dot(index.Field.Names[0].String()))
				indexer.List(jen.Id(index.indexFieldName()), jen.Id("indexExists")).Op(":=").Add(indexStore)
				indexer.If().Op("!").Id("indexExists").BlockFunc(func(indexNotExists *jen.Group) {
					indexNotExists.Id(index.indexFieldName()).Op("=").Make(jen.Map(index.fieldType()).Bool())
					indexNotExists.Add(indexStore).Op("=").Id(index.indexFieldName())
				})
				indexer.Add(indexStore).Index(jen.Id("id")).Op("=").True()
			}
			indexer.Line()
		}
		indexer.Id("storage").Dot("meta").Index(jen.Id("id")).Op("=").Id(metaName).ValuesFunc(func(group *jen.Group) {
			for _, index := range indexes {
				group.Id(index.Name()).Op(":").Id("value").Dot(index.Name())
			}
		})
	}).Line()
}

func removeFromIndex(storageName string, indexes []fieldIndex) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("removeItemFromIndex").Params(
		jen.Id("id").String(),
	).BlockFunc(func(indexer *jen.Group) {
		indexer.List(jen.Id("value"), jen.Id("exists")).Op(":=").Id("storage").Dot("meta").Index(jen.Id("id"))
		indexer.If().Op("!").Id("exists").Block(jen.Return())
		indexer.Delete(jen.Id("storage").Dot("meta"), jen.Id("id"))
		for i, index := range indexes {
			if i != 0 {
				indexer.Line()
			}
			indexer.Comment("remove from index by " + asWord(index.Field.Names[0].String()))
			if index.Unique {
				indexer.Delete(jen.Id("storage").Dot(index.indexFieldName()), jen.Id("value").Dot(index.Field.Names[0].String()))
			} else {
				indexStore := jen.Id("storage").Dot(index.indexFieldName()).Index(jen.Id("value").Dot(index.Field.Names[0].String()))
				indexer.Id(index.indexFieldName()).Op(":=").Add(indexStore)
				indexer.Delete(jen.Id(index.indexFieldName()), jen.Id("id"))
				indexer.If().Len(jen.Id(index.indexFieldName())).Op("==").Lit(0).BlockFunc(func(empty *jen.Group) {
					empty.Delete(jen.Id("storage").Dot(index.indexFieldName()), jen.Id("value").Dot(index.Field.Names[0].String()))
				})
			}
		}
	}).Line()
}

func remover(typeName string, storageName string) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("remove").Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("id").String(),
	).Error().BlockFunc(func(indexer *jen.Group) {
		indexer.Err().Op(":=").Id("storage").Dot("backend").Dot("Delete").Call(jen.Id("ctx"), jen.Id("id"))
		indexer.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return().Qual("fmt", "Errorf").Call(jen.Lit("delete "+typeName+"#%s: %w"), jen.Id("id"), jen.Err())
		})
		indexer.Id("storage").Dot("removeItemFromIndex").Call(jen.Id("id"))
		indexer.Return().Nil()
	}).Line()
}

func getter(typeName string, itemType *jen.Statement, storageName string) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("get").
		Params(jen.Id("ctx").Qual("context", "Context"), jen.Id("id").String()).
		Params(jen.Add(itemType), jen.Error()).BlockFunc(func(getter *jen.Group) {
		getter.List(jen.Id("data"), jen.Err()).Op(":=").Id("storage").Dot("backend").Dot("Get").Call(jen.Id("ctx"), jen.Id("id"))
		getter.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return(
				itemType.Clone().Values(),
				jen.Qual("fmt", "Errorf").Call(jen.Lit("fetch "+typeName+"#%s data: %w"), jen.Id("id"), jen.Err()),
			)
		})
		getter.Var().Id("result").Add(itemType)
		getter.Err().Op("=").Id("storage").Dot("decoder").Call(jen.Id("data"), jen.Op("&").Id("result"))
		getter.If().Err().Op("!=").Nil().BlockFunc(func(failed *jen.Group) {
			failed.Return(
				itemType.Clone().Values(),
				jen.Qual("fmt", "Errorf").Call(jen.Lit("decode "+typeName+"#%s fetched data: %w"), jen.Id("id"), jen.Err()),
			)
		})
		getter.Return(jen.Id("result"), jen.Nil())
	}).Line()
}

func uniqueConstraints(typeName string, itemType jen.Code, storageName string, indexes []fieldIndex) jen.Code {
	return jen.Func().Params(jen.Id("storage").Op("*").Id(storageName)).Id("unique").Params(
		jen.Id("value").Add(itemType),
	).Error().BlockFunc(func(indexer *jen.Group) {
		for _, index := range indexes {
			if index.Unique {
				param := jen.Id("value").Dot(index.Field.Names[0].String())
				indexer.IfFunc(func(check *jen.Group) {
					check.List(jen.Id("id"), jen.Id("exists")).Op(":=").Id("storage").Dot(index.indexFieldName()).Index(param)
					check.Id("exists")
				}).BlockFunc(func(failed *jen.Group) {
					failed.Return().Qual("fmt", "Errorf").Call(jen.Lit(asWord(typeName)+" with "+asWord(index.Field.Names[0].String())+" %s already exists as %s"), param, jen.Id("id"))
				})
			}
			indexer.Line()
		}
		indexer.Return().Nil()
	}).Line()
}

type fieldIndex struct {
	Field    *ast.Field
	Tags     *structtag.Tags
	Index    string
	Unique   bool
	TokenSet *token.FileSet
}

func (fi fieldIndex) indexFieldName() string {
	return "index" + strings.Title(fi.Index)
}

func (fi fieldIndex) accessor() string {
	return strings.Title(fi.Index)
}

func (fi fieldIndex) fieldType() jen.Code {
	return jen.Id(deepparser.AstPrint(fi.Field.Type, fi.TokenSet))
}

func (fi fieldIndex) Name() string {
	return fi.Field.Names[0].String()
}

func inspectStruct(typeDef *ast.TypeSpec, structDef *ast.StructType, tokenSet *token.FileSet) []fieldIndex {
	var indexes []fieldIndex
	for _, field := range structDef.Fields.List {
		if field.Tag == nil || len(field.Names) == 0 {
			continue
		}
		rawTag, _ := strconv.Unquote(field.Tag.Value)
		tags, err := structtag.Parse(rawTag)
		if err != nil {
			panic(err)
		}
		if value, err := tags.Get("index"); err == nil {
			indexName := value.Name
			if indexName == "" {
				indexName = "by" + strings.Title(field.Names[0].Name)
			}
			indexes = append(indexes, fieldIndex{
				Field:    field,
				Tags:     tags,
				Index:    indexName,
				Unique:   value.HasOption("unique"),
				TokenSet: tokenSet,
			})
		}
	}
	return indexes
}

func asVarName(str string) string {
	var runes = []rune(str)
	for i, r := range runes {
		if unicode.IsUpper(r) {
			runes[i] = unicode.ToLower(r)
		} else {
			break
		}
	}
	return string(runes)
}

func asWord(str string) string {
	var items = camelcase.Split(str)
	for i, it := range items {
		items[i] = strings.ToLower(it)
	}
	return strings.Join(items, " ")
}
